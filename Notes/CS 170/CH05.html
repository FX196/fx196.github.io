<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>CS 170 | Chapter 5</title>
    
    <!-- Bootstrap core CSS -->
    <link href="../../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom fonts for this template -->
    <link href="../../assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"
          type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
          rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Quattrocento" rel="stylesheet">
    
    <!-- MathJax Import -->
    <script async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
            type="text/javascript">
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    
    <script language="JavaScript" src="../../assets/js/main.js" type="text/javascript"></script>
    
    <script language="JavaScript" src="../../assets/js/cs170.js" type="text/javascript"></script>
    
    <!-- Custom styles for this template -->
    <link href="../../assets/css/main.css" rel="stylesheet">

</head>
<body>
<!-- Header and Nav Bar -->
<iframe id="header-frame" scrolling="no" src="../../assets/frames/header.html"></iframe>


<!-- Main Content -->
<h2 align="center" class="notes-title" style="padding-bottom: 20px">Chapter 5: Greedy Algorithms</h2>

<div class="container note-section">
    <ul>
        <li class="note-block">
            <h3>Greedy Algorithms</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Chooses action that provides most immediate benefit.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Minimum Spanning Trees</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Removing a cycle edge will not disconnect a graph.
                </li>
                <li class="note-item">
                    All spanning trees of graph \(G = (V, E) \) have \(|V|-1\) edges.
                </li>
                <li class="note-item">
                    Kruskal's Algorithm: repeatedly add lightest edge that doesn't create a cycle. <br>
                    Reverse Kruskal's: repeatedly remove largest edge that doesn't disconnect the graph.
                </li>
                <li class="note-item">
                    <b>Cut Property</b>: If edge \(e\) is the lightest edge across cut \((S, V-S)\), then \(e\) is a
                    part of <i>some</i> MST.
                </li>
                <li class="note-item">
                    <b>Cycle Property</b>: If edge \(e\) had weight larger than the sum of the other edges in a cycle
                    it's part of, it cannot be part of an MST.
                </li>
                <li class="note-item">
                    Prim's Algorithm: start with empty set of edges, repeatedly find cuts and add the lighest edge
                    across the cut. <br>
                    A straightforward way of obtaining cuts is 'growing' a tree \(T\). The cut is then \((T, V-T)\).
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Union-Find</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    makeset(x) - make a singleton set of vertex x.
                </li>
                <li class="note-item">
                    find(x) - find root of x's component.
                </li>
                <li class="note-item">
                    union(x, y) - merge x and y's components.
                </li>
                <li class="note-item">
                    For any x, the rank of x's parent is larger than the rank of x.
                </li>
                <li class="note-item">
                    For any node of rank \(k\) there are at least \(2^k\) nodes in its subtree.
                </li>
                <li class="note-item">
                    If there are \(n\) elements, there can be at most \(\frac{n}{2^k}\) elements of rank \(k\).
                </li>
                <li class="note-item">
                    Path compression: during find(x), make root the parent of all nodes on path from x to root.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Huffman Encoding</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Make each character into a node containing its frequency, heapify nodes.
                </li>
                <li class="note-item">
                    Cost of tree: \(\sum \limits_{i=1}^n f_i \cdot (\text{depth of }i\text{th symbol in tree)}\).
                </li>
                <li class="note-item">
                    Entropy: number of bits needed to encode sequence. <br>
                    \(\sum \limits_{i=1}^n p_i \log(\frac{1}{p_i})\)
                </li>
                <li class="note-item">
                    more compressible = less random = more predictable
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Horn Formulas</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Consists of <i>implications</i> and <i>negative clauses</i>
                </li>
                <li class="note-item">
                    <i>implications</i>: conjunctions of literals implying another literal. <br>
                    e.g. \((z \wedge x) \Longrightarrow y\)
                </li>
                <li class="note-item">
                    <i>negative clauses</i>: disjunctions of negative literals. <br>
                    e.g. \((\bar x \vee \bar y)\)
                </li>
                <li class="note-item">
                    <i>satisfying assignment</i>: a set of assignments to the literals that satisfy all the clauses.
                </li>
                <li class="note-item">
                    Greedy Algorithm: start with all false, for all literals, set right hand side to true if left is
                    true. <br>
                    If assignment satisfies negative clauses, return assignment, else return false.
                </li>
                <li class="note-item">
                    Algorithm assigns least number of variables to true / variables that algorithm sets to true must be
                    true in any satisfying assignment. <br>
                    <i>Proof</i>: algorithm only assigns variables to true if LHS of implication is true.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Distance from Optimality</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Example: Set Cover
                </li>
                <li class="note-item">
                    Greedy: repeatedly choose set \(S\) with largest number of uncovered elements.
                </li>
                <li class="note-item">
                    Optimal uses \(k\) sets, so after any number of iterations, the remaining vertices can be covered
                    with \(k\) sets.
                </li>
                <li class="note-item">
                    There is a set of at least \(n/k\) vertices, \(n = \) number of remaining vertices. Hence greedy leaves at
                    most \(n(1-\frac{1}{k})\) vertices.
                </li>
                <li class="note-item">
                    Since \(1-x \leq e^{-x}\), \(n_t \leq n_0(1-\frac{1}{k})^t \leq n_0(e^{-1/k})^t = n_0e^{-t/k}\) <br>
                    At \(t = k\ln n\), \(n_t < 1\). Hence greedy uses at most \(k \ln n\) sets.
                </li>
            </ul>
        </li>
        
        <li class="note-block">
            <h3>Exchange Argument</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Assume exists optimal solution with lower cost.
                </li>
                <li class="note-item">
                    Since lower cost, optimal solution \(O\) and greedy solution \(A\) must differ.
                </li>
                <li class="note-item">
                    Change \(O\) to make it more similar to \(A\) show that the change does not make the solution worse.
                </li>
                <li class="note-item">
                    Since any exchanges do not make \(O\) worse, there is no optimal solution with lower cost.
                </li>
            </ul>
        </li>
    
    </ul>
</div>

<!-- Footer -->
<iframe class="footer-frame" src="../../assets/frames/footer.html"></iframe>

<!-- Bootstrap core JavaScript -->
<script src="../../assets/vendor/jquery/jquery.min.js"></script>
<script src="../../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Custom scripts for this template -->
<script src="../../assets/js/clean-blog.min.js"></script>

</body>
</html>
