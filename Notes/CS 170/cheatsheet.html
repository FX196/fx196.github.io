<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>CS 170 | Chapter 5</title>
    
    <!-- Bootstrap core CSS -->
    <link href="../../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Custom fonts for this template -->
    <link href="../../assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet"
          type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
          rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Quattrocento" rel="stylesheet">
    
    <!-- MathJax Import -->
    <script async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
            type="text/javascript">
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    
    <script language="JavaScript" src="../../assets/js/main.js" type="text/javascript"></script>
    
    <script language="JavaScript" src="../../assets/js/cs170.js" type="text/javascript"></script>
    
    <!-- Custom styles for this template -->
    <link href="../../assets/css/main.css" rel="stylesheet">

</head>
<body>


<!-- Main Content -->
<h2 align="center" class="notes-title" style="padding-bottom: 20px">Midterm 2 Notes</h2>

<div class="container note-section">
    <ul>
        <li class="note-block">
            <h3>Minimum Spanning Trees</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Removing a cycle edge will not disconnect a graph.
                </li>
                <li class="note-item">
                    All spanning trees of graph \(G = (V, E) \) have \(|V|-1\) edges.
                </li>
                <li class="note-item">
                    Kruskal's Algorithm: repeatedly add lightest edge that doesn't create a cycle. <br>
                    Reverse Kruskal's: repeatedly remove largest edge that doesn't disconnect the graph.
                </li>
                <li class="note-item">
                    <b>Cut Property</b>: If edge \(e\) is the lightest edge across cut \((S, V-S)\), then \(e\) is a
                    part of <i>some</i> MST.
                </li>
                <li class="note-item">
                    <b>Cycle Property</b>: If edge \(e\) had weight larger than the sum of the other edges in a cycle
                    it's part of, it cannot be part of an MST.
                </li>
                <li class="note-item">
                    Prim's Algorithm: start with empty set of edges, repeatedly find cuts and add the lighest edge
                    across the cut. <br>
                    A straightforward way of obtaining cuts is 'growing' a tree \(T\). The cut is then \((T, V-T)\).
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Union-Find</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    For any node of rank \(k\) there are at least \(2^k\) nodes in its subtree.
                </li>
                <li class="note-item">
                    If there are \(n\) elements, there can be at most \(\frac{n}{2^k}\) elements of rank \(k\).
                </li>
                <li class="note-item">
                    Path compression: during find(x), make root the parent of all nodes on path from x to root.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Huffman Encoding</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Make each character into a node containing its frequency, heapify nodes.
                </li>
                <li class="note-item">
                    Cost of tree: \(\sum \limits_{i=1}^n f_i \cdot (\text{depth of }i\text{th symbol in tree)}\).
                </li>
                <li class="note-item">
                    Entropy: number of bits needed to encode sequence. <br>
                    \(\sum \limits_{i=1}^n p_i \log(\frac{1}{p_i})\)
                </li>
                <li class="note-item">
                    more compressible = less random = more predictable
                </li>
                <li class="note-item">
                    If some character occurs with frequency more than \(\frac{2}{5}\), there is always a code of length
                    1. <br>
                    If all characters occur with frequency less than \(\frac{1}{3}\), there is no code of length 1. <br>
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Horn Formulas</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Consists of <i>implications</i> and <i>negative clauses</i>
                </li>
                <li class="note-item">
                    <i>implications</i>: conjunctions of literals implying another literal. <br>
                </li>
                <li class="note-item">
                    <i>negative clauses</i>: disjunctions of negative literals. <br>
                </li>
                <li class="note-item">
                    <i>satisfying assignment</i>: a set of assignments to the literals that satisfy all the clauses.
                </li>
                <li class="note-item">
                    Greedy Algorithm: start with all false, for all literals, set right hand side to true if left is
                    true. <br>
                    If assignment satisfies negative clauses, return assignment, else return false.
                </li>
                <li class="note-item">
                    Algorithm assigns least number of variables to true / variables that algorithm sets to true must be
                    true in any satisfying assignment. <br>
                    <i>Proof</i>: algorithm only assigns variables to true if LHS of implication is true.
                </li>
                <li class="note-item">
                    Exists linear time algorithm.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Distance from Optimality</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Example: Set Cover
                </li>
                <li class="note-item">
                    Greedy: repeatedly choose set \(S\) with largest number of uncovered elements.
                </li>
                <li class="note-item">
                    Optimal uses \(k\) sets, so after any number of iterations, the remaining vertices can be covered
                    with \(k\) sets.
                </li>
                <li class="note-item">
                    There is a set of at least \(n/k\) vertices, \(n = \) number of remaining vertices. Hence greedy
                    leaves at
                    most \(n(1-\frac{1}{k})\) vertices.
                </li>
                <li class="note-item">
                    Since \(1-x \leq e^{-x}\), \(n_t \leq n_0(1-\frac{1}{k})^t \leq n_0(e^{-1/k})^t = n_0e^{-t/k}\) <br>
                    At \(t = k\ln n\), \(n_t < 1\). Hence greedy uses at most \(k \ln n\) sets.
                </li>
            </ul>
        </li>
        
        <li class="note-block">
            <h3>Exchange Argument</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Assume exists optimal solution with lower cost.
                </li>
                <li class="note-item">
                    Since lower cost, optimal solution \(O\) and greedy solution \(A\) must differ.
                </li>
                <li class="note-item">
                    Change \(O\) to make it more similar to \(A\) show that the change does not make the solution worse.
                </li>
                <li class="note-item">
                    Since any exchanges do not make \(O\) worse, there is no optimal solution with lower cost.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Linear Programming</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">Maximizing or minimizing an objective function under a list of constraints</li>
                <li class="note-item">Each constraint is a linear <i>in</i>equation forming a half-space</li>
                <li class="note-item">Optimum is reached at vertices unless:</li>
                <ol>
                    <li class="note-item">program is <i>infeasible</i>, e.g. \(x \leq 1, x \geq 2\)</li>
                    <li class="note-item">program is <i>unbounded</i>, i.e. it's possible to reach arbitrarily high/low
                        values
                    </li>
                </ol>
            </ul>
            <h3>Simplex Algorithm</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">Start at a vertex, looks at neighboring vertices for a higher value</li>
                <li class="note-item">Does <i>hill-climbing</i> on the vertices.</li>
                <li class="note-item">Local optimality implies global optimality</li>
                <li class="note-item" style="list-style: none">
                    <ul>
                        <li style="padding-left: 20px">- if all neighbours are on one side
                            of the "profit" plane, the rest must also be on the same side
                        </li>
                    </ul>
                </li>
            </ul>
            <h3>Flows in Networks</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Maximize flow from vertices \(s\) to \(t\) in <b>directed</b> graph \(G = (V,E)\)
                </li>
                <li class="note-item">Derived algorithm (what simplex is essentially doing)</li>
                <li class="note-item" style="list-style: none">
                    <ol>
                        <li class="note-item">Start with 0 flow</li>
                        <li class="note-item">Choose an appropriate path from <i>s</i> to <i>t</i>, and increase flow as
                            much as possible along
                            this path.
                        </li>
                    </ol>
                </li>
                <li class="note-item">
                    Simplex allows paths to cancel existing flow
                </li>
                <li class="note-item">
                    For each iteration, the \(s-t\) path has edges \((u, v)\) that:
                </li>
                <li class="note-item" style="list-style: none">
                    <ol>
                        <li class="note-item">
                            Are in the original network, and is not at full capacity, or
                        </li>
                        <li class="note-item">
                            Is the reverse of an edge \((v, u)\) in the network, and has flow along it
                        </li>
                    </ol>
                </li>
                <li class="note-item">Residual network \(G^f\)</li>
                <li class="note-item">
                    \(c^f = \begin{cases}
                    c_{uv}-f_{uv} & \text{if $(u,v) \in E$ and $f_{uv} < c_{uv}$} \\
                    f_{vu} & \text{if $(v,u) \in E$ and $f_{vu}>0$}
                    \end{cases}\)
                </li>
                <li class="note-item">For any flow \(f\) and any \((s,t)\)-cut \((L,R)\), size(\(f\)) \(\leq\) capacity
                    \((L,R)\)
                </li>
                <li class="note-item"><b class="note-inline">Max-flow min-cut theorem</b>
                    <i>The size of the maximum flow in the network equals the capacity of the smallest \({s,t}\)-cut</i>
                </li>
                <li class="note-item">
                    Min-cut \((L,R)\): \(L\) is all the nodes reachable in the residual graph \(G^f\) from \(s\) at
                    final flow, \(R = V - L\). Any
                    edge from \(L\) to \(R\) must have max flow, any edge from \(R\) to \(L\) must have 0 flow.
                </li>
                <li class="note-item">Use residual network with derived algorithm instead</li>
                <li class="note-item">\(O(|E|)\) to find \(s-t\) path for each iteration.</li>
                <li class="note-item">Number of iterations is at most \(O(|V| \cdot |E|)\) if paths are found with BFS
                    (path with fewest edges)
                </li>
                <li class="note-item"><b class="note-inline">Overall runtime for maximum flow:</b>\(O(|V|\cdot
                    |E|^2)\)
                </li>
                <li class="note-item">Guarantees integrality if all edge capacities are integral. (see derived
                    algorithm)
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Bipartite Matching</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">Can be cast to max-flow</li>
                <li class="note-item">Add source node connected to one partition, sink to other;
                    Set all capacities to 1.
                </li>
            </ul>
        </li>
        <li class="note-block">
            <h3>Duality</h3>
            <hr class="note-line">
            <ul class="note-list">
                <li class="note-item">
                    Every linear maximization problem has a <i>dual</i> linear minimization problem
                </li>
                <li class="note-item">
                    Variables of dual are multipliers of the inequalities of primal
                </li>
                <li id="dual-eg" style="list-style: none; display: none">
                    <ul>
                        <li class="note-item" style="list-style: none">
                            \(\begin{align}
                            \text{max } x_1 &+ 6x_2 \\
                            x_1 &\leq 200 \\
                            x_2 &\leq 300 \\
                            x_1 + x_2 &\leq 400 \\
                            x_1, x_2 &\geq 0
                            \end{align}\)
                        </li>
                        <li class="note-item" style="list-style: none">
                            \(\begin{alignat*}{3}
                            \text{Multiplier}\qquad& \text{Inequality}&&\\
                            y_1\qquad& x_1&&\leq 200 \\
                            y_2\qquad& x_2 &&\leq 300 \\
                            y_3\qquad& x_1 + x_2 &&\leq 400 \\
                            \end{alignat*}\)
                        </li>
                        <li class="note-item" style="list-style: none">
                            \((y_1 + y_3)x_1 + (y_2 + y_3)x_2 ≤ 200y_1 + 300y_2 + 400y_3\)
                        </li>
                        <li class="note-item" style="list-style: none">
                            \(
                            x_{1}+6 x_{2} \leq 200 y_{1}+300 y_{2}+400 y_{3} \quad \text { if } \quad
                            \left\{\begin{array}{c}{y_{1}, y_{2}, y_{3} \geq 0} \\ {y_{1}+y_{3} \geq 1} \\ {y_{2}+y_{3}
                            \geq
                            6}\end{array}\right\}
                            \)
                        </li>
                        <li class="note-item" style="list-style: none">
                            So the initial problem has a <i>dual</i> minimization problem:<br><br>
                            \(
                            \begin{array}{c}{\min 200 y_{1}+300 y_{2}+400 y_{3}} \\ {y_{1}+y_{3} \geq 1} \\ {y_{2}+y_{3}
                            \geq 6}
                            \\ {y_{1}, y_{2}, y_{3} \geq 0}\end{array}
                            \)
                        </li>
                    </ul>
                </li>
                <li class="note-item">
                    Relation between Dual and Primal: <br>
                    \(
                    \begin{array}{c}{\text { Primal LP: }} \\ { \text {max } \mathbf{c}^{T} \mathbf{x}} \\
                    {\mathbf{A} \mathbf{x} \leq \mathbf{b}} \\ {\quad\mathbf{x} \geq 0}\end{array}
                    \qquad
                    \begin{array}{c}{\text { Dual LP: }} \\ {\text { min } \mathbf{y}^{T} \mathbf{b}} \\
                    {\mathbf{y}^{T} \mathbf{A} \geq \mathbf{c}^{T}} \\ {\quad\mathbf{y} \geq 0}\end{array}
                    \)
                </li>
                <li class="note-item"><b>Duality theorem</b> <i>If a linear program has a bounded optimum, then so does
                    its dual, and
                    the
                    two optimum values coincide</i></li>
                <li class="note-item">The dual of the max-flow problem is the min-cut problem</li>
            </ul>
        </li>
    </ul>
</div>

<!-- Bootstrap core JavaScript -->
<script src="../../assets/vendor/jquery/jquery.min.js"></script>
<script src="../../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

<!-- Custom scripts for this template -->
<script src="../../assets/js/clean-blog.min.js"></script>

</body>
</html>
